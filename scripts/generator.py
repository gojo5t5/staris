import os

import sys
scriptDir = os.path.dirname(os.path.realpath(__file__))
sys.path.append(scriptDir)

from essence_pipeline_utils import conjure_translate_parameter, savilerow_translate, run_minion, parse_minion_solution, savilerow_parse_solution, conjure_translate_solution

from utils import delete_file, log

def solve_generator(configurationId, paramDict, setting, seed, detailedOutputDir):
    ### create a new instance by solving a generator instance ###
    # we need to make sure that we don't create an instance more than once from the same generator instance
    # this is done by generating the minion instance file only once, and everytime a new solution is created, it'll be added to a negative table in the minion file
    # NOTE 1: we save the generated minion file because we want to save SR time next time the same configuration is run by irace. However, this increases the storage memory used during the tuning, as those minion files can be huge!
    # NOTE 2: the generated solution will only be added to the minion file at the end of a wrapper run (when the corresponding problem instance is successfully taken by the considered target solvers) by calling function save_generator_solution. This is to make sure that if a run is unsuccessful and terminated, the same instance will be generated when the tuning is resumed.

    # write generator instance to an essence instance file
    paramFile = detailedOutputDir + '/gen-inst-' + str(configurationId) + '.param'
    print('\n')
    log("Creating generator instance: " + paramFile) 
    lsLines = ['letting ' + key + ' be ' + str(val) for key, val in paramDict.items()]
    with open(paramFile, 'wt') as f:
        f.write('\n'.join(lsLines))
    
    # files used/generated during the solving process
    eprimeModelFile = detailedOutputDir + "/generator.eprime"
    baseFileName = paramFile.replace('.param','')
    minionFile = baseFileName + '.minion' # minion input file, including a negative table saving previously generated solutions of the same generator instance
    minionSolFile = baseFileName + '.solution' # solution file generated by minion, will be removed afterwards
    auxFile = baseFileName + '.aux' # aux file generated by SR, will be kept so we don't have to re-generate it next time solving the same generator instance
    eprimeSolFile =  baseFileName + '.solution.eprime-param' # eprime solution file created by SR, will be removed afterwards
    essenceSolFile = baseFileName + '.solution.param' # essence solution file created by conjure, will be returned as a problem instance
    minionSolString = '' # content of minion solution file, to be added to minion negative table in minionFile
    
    # status of the solving
    genStatus = None # SRTimeOut/SRMemOut/solverTimeOut/solverMemOut/sat/unsat

    # if the generator instance is solved for the first time
    if (not os.path.exists(minionFile)) or (os.stat(minionFile).st_size == 0):
        eprimeParamFile = baseFileName + '.eprime-param'
        conjure_translate_parameter(eprimeModelFile, paramFile, eprimeParamFile) # translate generator instance from Essence to Essence Prime
        genStatus, genSRTime = savilerow_translate(auxFile, eprimeModelFile, eprimeParamFile, minionFile, setting['genSRTimelimit'], setting['genSRFlags']) # translate generator instance from Essence Prime to minion input format
        os.remove(eprimeParamFile)
    else:
        genStatus = 'SRok'
        genSRTime = 0

    # start solving it
    if genStatus == 'SRok':
        genStatus, genSolverTime = run_minion(minionFile, minionSolFile, seed, setting['genSolverTimelimit'], setting['genSolverFlags'])
        if genStatus == 'sat':
            minionSolString = parse_minion_solution(minionSolFile)
            savilerow_parse_solution(eprimeModelFile, minionSolFile, auxFile, eprimeSolFile) # parse solution from minion to Essence Prime
            conjure_translate_solution(eprimeModelFile, paramFile, eprimeSolFile, essenceSolFile) # parse solution from Essence Prime to Essence
        delete_file([minionSolFile,eprimeSolFile]) # delete minionSolFile after used, otherwise the negativetable will have duplicated items. eprimeSolFile is removed to make sure that in the next runs, if no solution is found by minion, no Essence solution file is created
    else:
        genSolverTime = 0

    # print out results of the generator solving process
    localVars = locals()
    print('\n')
    log("\nGenerator results: genInstance=" + os.path.basename(paramFile).replace('.param','') + ', ' + ', '.join([name + '=' + str(localVars[name]) for name in ['genStatus','genSRTime','genSolverTime']]))

    results = {'instance': os.path.basename(paramFile), 'status': genStatus, 'seed':seed, 'SRTime': genSRTime, 'solverTime': genSolverTime}    
    
    return genStatus, essenceSolFile, minionFile, minionSolString, results

